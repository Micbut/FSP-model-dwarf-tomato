////////////////////////////////////////////////////////////////////////////////	
//README! 
//Settings before start:
// set the right column separator in the method to read CSV files
// set the right columns for plant column and plant row in the axiom
// set in the script the right column names to retrieve the corresponding information from the MTG file
////////////////////////////////////////////////////////////////////////////////	
import static rewrite_rules.*;
import static parameters.*;
import static parameters_derived.*;
import static organs.*;
import static plant_level.*;
import static crop_level.*;
import static photosynthesis.*;
import static light.*;
import static surroundings.*;
import static initiation.*;
import static auxiliary_tools_and_charts.*;
import static updates.*;

import java.util.Arrays; 
import java.util.ArrayList;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.stream.IntStream;
	
////////////////////////////////////////////////////////////////////////////////	
// Read input parameters from a csv file
////////////////////////////////////////////////////////////////////////////////

static String[][] readMTGData(String input) throws FileNotFoundException, IOException {
	ArrayList data = new ArrayList();
	BufferedReader br = new BufferedReader(new FileReader(input));
	String line = "";
	String csvSplitBy = ",";	// separator
	int nrLineToSkip ;
	if (isStatic){ nrLineToSkip = 78;}else{ nrLineToSkip = 122;}
		// skip first lines of the MTG file because they store informations we don't need
	for (int r = 1; r < nrLineToSkip; r++)
	{
		line = br.readLine();
	}
	while (line != null) 
	{
		line = line.replaceAll("-", "");
		data.add(line.split(csvSplitBy, -1));	// -1: include empty cells
		line = br.readLine();
	}
	return (String[][]) data.toArray(new String[data.size()][]);
}

static float[] processString(String str) {
	// Check if the string is not empty
	if (!str.isEmpty()) {
		// Splitting the string by semicolons
		String[] strNumbers = str.split(";");

		// Creating an array to hold the float values
		float[] numbers = new float[strNumbers.length];

		// Parsing each string segment to a float and storing in the array
		for (int i = 0; i < strNumbers.length; i++) {
			numbers[i] = Float.parseFloat(strNumbers[i].trim());
		}

	return numbers;
	}
}

////////////////////////////////////////////////////////////////////////////////	
///Select a specific column from a matrix and make an array out of it
////////////////////////////////////////////////////////////////////////////////	

static int[] getColumn(String[][] array, int index) {
	int[] column = new int[array.length];
	for(int i=1; i<column.length; i++)
	{
		if (array[i][index].isEmpty())
		{
			column[i] = 0;
		}
		else // namely: if the field is not empty
		{ 
			column[i] = Integer.parseInt(array[i][index]);    // namely: convert String to Integer
		}
	}
    return column;
}

////////////////////////////////////////////////////////////////////////////////	
/// Find the max number in an array of integers
////////////////////////////////////////////////////////////////////////////////	

static int findMax(int[] array) {
	int max;
	for (int i = 1; i < array.length-1; i++) 
	{
		int column = array[i];   
            if (max < column) 
            {
                max = column;     
            }
    }
    return max;
}

////////////////////////////////////////////////////////////////////////////////
//PARAMETERS MTG FILE
////////////////////////////////////////////////////////////////////////////////

static int	column_ID	=	6	;
static int	column_order	=	7	;
static int	column_rank	=	8	;
static int	column_probability	=	9	;
static int	column_counterClockWiseOrientation	=	10	;
static int	column_counterClockWiseOrientation_sd	=	11	;
static int	column_inclination	=	12	;
static int	column_inclination_sd	=	13	;
static int	column_length	=	14	;
static int	column_length_sd	=	15	;
static int	column_width	=	16	;
static int	column_dry_biomass_mg	=	17	;
static int	column_dry_biomass_mg_sd	=	18	;
static int	column_dry_biomass_potential_max_mg	=	19	;
static int	column_growth_duration_dd	=	20	;
static int	column_age_maximum_growth_dd	=	21	;
static int	column_degreeDays	=	22	;
static int	column_TOP_SPD	=	37	;
static int	column_TOP_SPT	=	38	;
static int	column_BOTTOM_SPD	=	39	;
static int	column_BOTTOM_SPT	=	40	;
static boolean internode_present;

static float branch_inclination_correction_SA;
//WARNING! The model include a correct simulation of probability just for the main stem internodes - the oder orders still need to be implemented
static void createMTG(PlantBase pb){[
(*cb:CropBase (-->)+ pb *)rh:RH s:Sphere ==> 
    rh
    for(int row = 0; row < MTG.length; row++) (
        if(!MTG[row][0].isEmpty()) ([
            Translate(0.1*row,0.1*row, 0) // Here arbitrary distances are chosen at the moment
            { 	
                //	p[idRow] = Integer.parseInt( MTG[row][columnPlantRow]); 
                //	p[idColumn] = Integer.parseInt( MTG[row][columnPlantColumn]); 
            }[r:Root] {r.initiate(pb);}
            {row++;}
            {boolean exit0 = false;}
            do (
                if(!MTG[row][1].isEmpty()) (
                    {
                        char firstSymbol = MTG[row][1].charAt(0);
                        char secondSymbol = MTG[row][1].charAt(1);
                    }
                    if(firstSymbol == 'I' && probability(Float.parseFloat(MTG[row][column_probability]))) (
                        {
                            float counterClocKWiseOrientation = normal(Float.parseFloat(MTG[row][column_counterClockWiseOrientation]), Float.parseFloat(MTG[row][column_counterClockWiseOrientation_sd]));
                            float inclination = normal(Float.parseFloat(MTG[row][column_inclination]), Float.parseFloat(MTG[row][column_inclination_sd]));
                        }
                        RH(counterClocKWiseOrientation)
                        RL(inclination)
                        it:Internode {it.mtgConstructor(row,pb);}
                        RL(-inclination)
                        RH(-counterClocKWiseOrientation)
                    ) else if(firstSymbol == 'M') (
                        m:Meristem {m.mtgConstructorMain(row,pb);} 
                    ) else if(firstSymbol == 'S') (
                        [m:Meristem {m.mtgConstructorSide(row,pb);} ]
                    ) else (
                        {break;}
                    )
                )
                ///////
                if(MTG[row][1].isEmpty() ) ([
                    /////////////////branching
                    {boolean exit = false ;}
                    do ( 
                       if(!MTG[row][2].isEmpty()) ( /////1 st branchin
                            {
                                char firstSymbol = MTG[row][2].charAt(0);
                                char secondSymbol = MTG[row][2].charAt(1);
                            }
                            if(firstSymbol == 'x'&& probability(Float.parseFloat(MTG[row][column_probability]))) (  	
                                if(secondSymbol == 'L' ) ([
                                    l:Leaf {l.mtgConstructor(row,pb);}
                                ]) else if(secondSymbol == 'I' ) (
                                    {
                                        float counterClocKWiseOrientation = normal(Float.parseFloat(MTG[row][column_counterClockWiseOrientation]), Float.parseFloat(MTG[row][column_counterClockWiseOrientation_sd]));
                                        float inclination_helper = normal(Float.parseFloat(MTG[row][column_inclination]), Float.parseFloat(MTG[row][column_inclination_sd]));
                                        float inclination = SA_factor_BRANCH_INCLINATION_MEAN * inclination_helper;
                                        branch_inclination_correction_SA = inclination_helper - inclination;
                                    }
                                    RH(counterClocKWiseOrientation)
                                    RL(inclination)
                                    it:Internode {it.mtgConstructor(row,pb);}
                                    RL(-inclination)
                                    RH(-counterClocKWiseOrientation)
                                          
									if ((!MTG[row+1][2].isEmpty() && MTG[row+1][2].charAt(0) == 'x') || !MTG[row+1][1].isEmpty()) {
										exit = true;
									}

												
                                    //////////////////////
                              	 if(MTG[row+1][1].isEmpty() && (!MTG[row+1][2].isEmpty() || !MTG[row+1][3].isEmpty())) ([
                                   	 		{row++;}
                    						{boolean exit2 = false ;}
                    						do ( { 
                    								if(!MTG[row][2].isEmpty()){
                    									firstSymbol = MTG[row][2].charAt(0);
                    									secondSymbol = MTG[row][2].charAt(1);
                    								}else if(!MTG[row][3].isEmpty()){
                    									firstSymbol = MTG[row][3].charAt(0);
                    									secondSymbol = MTG[row][3].charAt(1);
                    								}
                    							}
 
                    							
												if (firstSymbol == 'I' &&  probability(Float.parseFloat(MTG[row][column_probability]))) (
			  
													{
														 counterClocKWiseOrientation = normal(Float.parseFloat(MTG[row][column_counterClockWiseOrientation]), Float.parseFloat(MTG[row][column_counterClockWiseOrientation_sd]));
														 inclination = -branch_inclination_correction_SA + normal(Float.parseFloat(MTG[row][column_inclination]), Float.parseFloat(MTG[row][column_inclination_sd]));
													}
													RH(counterClocKWiseOrientation)
													RL(inclination)
													it2:Internode {it2.mtgConstructor(row,pb);}
													RL(-inclination)
													RH(-counterClocKWiseOrientation)
											//AA BEGIN//		
													if(MTG[row+1][2].isEmpty() && (!MTG[row+1][3].isEmpty())) ([
		
														{row++;}
														{boolean exit3 = false ;}
														do ( {
																 firstSymbol = MTG[row][3].charAt(0);
																 secondSymbol = MTG[row][3].charAt(1);
															}
															if(firstSymbol == 'x'&& probability(Float.parseFloat(MTG[row][column_probability]))) (  	
																if(secondSymbol == 'L' ) ([
																	l:Leaf {l.mtgConstructor(row,pb);}
																])
															)else(
																{exit3=true;}
															)                        
															
															if(row+1 == MTG.length || (MTG[row+1][3].isEmpty()) || MTG[row+1][3].charAt(0) == 'x'|| MTG[row+1][2].charAt(0) == 'x') {
															//exit if this is also the end of the second order branch
																exit3 = true; 
															} else {
																row++;	
															}
														)while (!exit3)]
													)  
												//AA//	
													
												)else if(!MTG[row][3].isEmpty() && secondSymbol == 'L' ) ([
													if(probability(Float.parseFloat(MTG[row][column_probability])))(
                    									l:Leaf {l.mtgConstructor(row,pb);})
                    							])	else(
													{exit2=true;}
												)                        
												
												if(row+1 == MTG.length || (MTG[row+1][2].isEmpty()) || MTG[row+1][2].charAt(0) == 'x') {
												//exit if this is also the end of the second order branch
												exit2 = true; 
												} else {
													row++;	
													}
                                
									 )while (!exit2)]) 
								////////////////////////
                                    
                                )else ({exit=true;})
                            ) )
                        if(row+1 == MTG.length || (MTG[row+1][2].isEmpty()) || MTG[row+1][2].charAt(0) == 'x') {
                                //exit if this is also the end of the second order branch
                                exit = true; 
                            } else {
                                row++;	
                            }
                       
                    ) while (!exit)
                ])
                /////////
                if(row+1 == MTG.length || !MTG[row+1][0].isEmpty()) {
                    //exit if this is also the end of the second order branch
                    exit0 = true; 
                } else {
                    row++;	
                }
            ) while (!exit0)
        ])									
    )
;
]
}

